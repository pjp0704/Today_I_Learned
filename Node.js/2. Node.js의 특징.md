# Node.js의 특징

## 이벤트 기반

이벤트 기반(event-driven)이란, 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식을 의미한다. 이벤트로는 클릭이나 네트워크 요청 등이 예시가 될 수 있다.

이벤트 기반 시스템에서는 특정 이벤트가 발생할 때 무엇을 해야 할 지 미리 등록해 두어야 한다. 이를 이벤트 리스너(event listener)에 콜백(callback)함수를 등록한다고 표현한다.

노드도 이벤트 기반 방식으로 동작하므로, 이벤트가 발생할 때까지 대기했다가 이벤트 발생 시 이벤트 리스너에 등록해둔 콜백 함수를 호출하는 방식으로 동작한다.

이러한 구조의 모델에서는 이벤트 루프(event loop)라는 개념이 등장한다. 노드는 기본적으로 자바스크립트 코드의 맨 위부터 한 줄씩 실행한다. 함수 호출 코드를 발견하면 호출한 함수를 호출 스택(call stack)에 넣는다.

다음 코드의 실행 순서를 예측해 보자:

    function first() {
        second();
        console.log('첫 번째');
    }
    function second() {
        third();
        console.log('두 번째');
    }
    function third() {
        console.log('세 번째');
    }
    first();

실행 결과는 아래와 같다:

    세 번째
    두 번째
    첫 번째

이는 함수가 호출 스택에 쌓이는 순서가 first, second, third 순으로 쌓이고, 실행될 때는 반대로 third, second, first 순서대로 실행되기 때문이다.

그럼 이번에는 특정 시간 이후에 코드를 실행하는 setTimeout을 사용하는 예시를 들어 보자. 마찬가지로 다음 코드의 실행 순서를 예측해 보자:

    function run() {
        console.log('3초 후 실행');
    }
    console.log('시작');
    setTimeout(run, 3000);
    console.log('끝');

실행 결과는 아래와 같다:

    시작
    끝
    3초 후 실행

이 결과를 예측하는 것 자체는 쉬운 일일 것이다. 그렇다면 호출 스택만으로 위의 코드의 실행 순서를 설명할 수 있는가?

아마도 불가능할 것이다. setTimeout 함수의 콜백인 run이 언제 호출 스택에 들어가게 되는지 위에 있는 내용만으로는 파악할 수 없기 때문이다. 이를 파악하기 위해서는 이벤트 루프(event loop), 태스크 큐(task queue), 백그라운드(background)를 알아야 한다.

위의 3개를 간략히 설명하면 다음과 같다:

- 이벤트 루프: 이벤트 발생 시 호출할 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 결정하는 역할을 담당한다. 노드가 종료될 때까지 이러한 작업을 반복하므로 루프(loop)라고 한다.
- 백그라운드: setTimeout과 같은 타이머나 이벤트 리스터들이 대기하는 곳이다. 자바스크립트가 아닌 다른 언어로 작성된 프로그램이라고 봐도 된다. 여러 작업이 동시에 실행될 수 있다.
- 태스크 큐: 이벤트 발생 후, 백그라운드에서는 태스크 큐로 타이머나 이벤트 리스너의 콜백 함수를 보낸다. 콜백들은 보통 완료된 순서대로 줄을 서 있지만 특정한 경우에는 순서가 바뀌기도 한다.

위의 코드가 실행되는 내부 과정은:

1. 먼저 전역 컨텍스트인 anonymous가 호출 스택에 들어간다. 그 뒤 setTimeout이 호출 스택에 들어간다.
2. 호출 스택에 들어간 순서와 반대로 실행되므로, setTimeout이 먼저 실행된다. setTimeout이 실행되면 타이머와 함께 run 콜백을 백그라운드로 보내고, setTImeout은 호출 스택에서 빠진다. 이후 anonymous도 호출 스택에서 빠진다.
3. 백그라운드에서는 3초를 센 후 run 함수를 태스크 큐로 보낸다. 3초를 세었다는 것은 백그라운드에 맡겨진 작업이 완료된 것으로 이해해도 된다.
4. 이후 호출 스택이 비었을 때 이벤트 루프가 태스크 큐에 있는 run 콜백을 호출 스택으로 올린다. 이 run은 실행된 후 호출 스택에서 빠진다.

이때 호출 스택에 함수들이 너무 많이 들어 있으면 3초가 지난 후에도 run 함수가 실행되지 않을 수도 있다. 이는 이벤트 루프가 호출 스택이 비어 있을 경우에만 태스크 큐에 있는 함수를 호출 스택으로 올리기 때문이며, 따라서 setTimeout의 시간이 정확하지 않을 수 있다.

## 논 블로킹 I/O

이벤트 루프를 잘 활용한다면 올 ㅐ걸리는 작업을 효율적으로 처리할 수도 있다.

작업에는 크게 두 종류가 있다. 동시에 실행될 수 있는 작업과 동시에 실행될 수 없는 작업이다. 기본적으로 우리가 작성한 자바스크립트 코드는 동시에 실행될 수 없다. 하지만 자바스크립트 상에서 동작하는 것이 아닌, I/O 작업 등은 동시에 처리할 수 있다.

I/O는 입출력을 의미하므로, 이는 파일 시스템 접근이나 네트워크를 통한 요청 등을 말한다. 이러한 작업을 할 때 노드는 논 블로킹 방식으로 처리하는 방법을 제공하는데, **논 블로킹**이란 이전 작업이 완료될 때까지 기다리는 것이 아니라 그 사이에 다음 작업을 수행하는 것을 말한다.

논 블로킹 방식이 같은 작업들을 더 짧은 시간에 처리할 수 있다. 하지만 작업들이 **모두 동시에 처리될 수 있는** 작업이라는 전제가 필요하다.

Node는 I/O 작업을 백그라운드에 넘겨 동시에 처리하곤 한다. 따라서 동시에 처리될 수 있는 작업들을 최대한 묶어서 백그라운드로 넘겨야 시간을 절약할 수 있다.

물론 아무리 논 블로킹 방식으로 코드를 작성하더라도, 코드에 I/O 작업이 존재하지 않는 등의 경우에는 전체 소요 시간이 짧아지지는 않는다. 이는 코드가 서로 동시에 실행되지 않기 때문이며, 따라서 단순히 실행 순서가 바뀌는 결과만 가져온다. 물론 그렇다고 해서 의미가 없는 것은 아닌데, 오래 걸리는 작업을 뒤로 넘겨 간단한 작업을 먼저 처리하는 식의 사용도 충분히 가능하기 때문이다.

또한 **논 블로킹**과 **동시**는 같은 의미가 아니다. 동시성은 동시 처리가 가능한 작업을 논 블로킹 처리해야 얻을 수 있는 것이다.

## 싱글 스레드

싱글 스레드란 말 그대로 스레드가 하나라는 것을 의미한다. 이는 우리가 작성한 자바스크립트 코드가 동시에 실행될 수 없는 이유이기도 하다.

스레드를 이해하려면 프로세스를 먼저 알아야 한다. 프로세스와 스레드의 차이는 다음고 ㅏ같다:

- 프로세스는 운영체제에서 할당하는 작업의 단위이다. 노드나 웹 브라우저 같은 프로그램이 개별적인 프로세스이며, 프로세스 간에는 메모리 등의 자원을 공유하지 않는다.
- 스레드는 프로세스 내에서 실행되는 흐름의 단위이다. 프로세스는 스레드를 여러 개 생성하여 여러 작업을 동시에 처리할 수 있으며, 부모 프로세스의 자원을 공유한다. 또한 같은 주소의 메모리에 접근이 가능하므로 데이터를 공유할 수 있다.

노드는 싱글 스레드라고 익히 알려져 있지만, 엄밀히 말하면 싱글 스레드만으로 동작하지는 않는다. 정확히는 노드를 실행하면 프로세스가 생성되고, 내부적으로 스레드를 여러 개 생성한다. 그렇지만 그중 직접 제어할 수 있는 스레드는 하나뿐이기에 흔히 노드가 싱글 스레드라고 말하는 것이다.

하나의 스레드만 조작할 수 있으므로 요청이 많이 들어오면 한 번에 하나씩 요청을 처리한다. 블로킹이 심하게 일어나는 작업을 직접 처리하지만 스레드 하나로도 충분하다. 블로킹이 발생할 것 같다면 논 블로킹 방법으로 대기 시간을 최대한 줄인다.

> 노드가 싱글 스레드로 동작하지 않는 경우가 두 가지 있는데, 스레드 풀(Thread Pool)과 워커 스레드(Worker Thread)이다.
>
> 스레드 풀은 노드가 특정 동작을 수행할 때 스스로 멀티 스레드를 사용하는 것이다. 대표적인 예로는 암호화, 파일 입출력, 압축 등이 있다.
>
> 워커 스레드는 Node.js 12 버전에서 안정화된 기능으로, 노드에서 직접 다수의 스레드를 다룰 수 있는 기능이다.

단순히 보면 여러 개의 일을 동시에 처리할 수 있는 멀티 스레드가 싱글 스레드보다 뛰어나 보인다. 하지만 꼭 그런 것은 아니다. 예를 들자면,

음식점에 점원이 한 명 있다. 손님은 여러 명이며, 점원 한 명이 주문을 받아 주방에 넘기고, 주방에서 요리가 나오면 손님에게 서빙한다. 그 후 다음 손님의 주문을 받는다.

이러한 구조(싱글 스레드, 블로킹)의 단점은, 다음 손님은 이전 손님의 요리가 나올 때까지 하염없이 기다려야 주문할 수 있다는 점이다. 다른 예시를 들어 보자.

점원이 한 손님의 주문을 받고, 주문 내역을 주방에 넘긴 뒤 다음 손님의 주문을 받는다. 요리가 끝나기까지 기다리지 않고 주문을 주방에 알려주기만 한다. 주방에서 요리가 완료되는 순서대로 손님에게 서빙한다. 요리에 따라 완료되는 순서가 다를 수 있으므로, 주문이 들어온 순서와 서빙하는 순서는 일치하지 않을 수 있다.

이러한 구조(싱글 스레드, 논 블로킹)가 노드가 채택하고 있는 방식으로, 점원은 한 명이지만 위의 예시와 비교한다면 혼자서 많은 일을 처리할 수 있게 됐다. 하지만 문제가 없는 것은 아닌데, 한 명밖에 없는 점원이 모종의 이유로 일을 못하게 되기라도 한다면 큰 문제가 생길 수 있다. 또한 요리가 오래 걸리게 된다면 주문이 많이 들어왔을 때 버거울 수도 있다.

멀티 스레드 방식을 점원을 비교하면, 손님 한 명이 올 때마다 점원도 한 명씩 붙어서 주문을 받고 서빙한다. 이 방식에는 장단점이 있는데, 일단 손님 한 명당 점원도 한 명이면 서빙 자체는 걱정이 없지만, 손님의 수가 늘어날수록 점원의 수도 늘어난다. 손님 수가 줄어들면 일을 하지 않고 노는 점원이 있게 된다는 것도 문제이며, 점원을 새로 고용하거나 기존 점원을 해고할 때는 그에 따른 비용이 발생한다.

물론 점원 여러 명이 모두 논 블로킹 방식으로 주문을 받으면 더 좋다. 다만 이렇게 작업하는 경우에는 프로그래밍이 상당히 어려워지므로 멀티 프로세싱 방식을 사용하며, I/O 요청에는 일반적으로 멀티 프로세싱이 더 효율적이기도 하다. 그래서 노드는 멀티 프로세싱을 많이 한다.
