# 노드에서 파일 시스템에 접근하기

fs 모듈은 파일 시스템에 접근하는 역할을 하는 모듈이다. 파일을 생성하거나 삭제하고, 읽거나 쓸 수 있으며, 폴더도 만들거나 지울 수 있다.

## fs 모듈의 사용법

```javascript
const fs = require("fs");

fs.readFile("./test.txt", (err, data) => {
  if (err) {
    throw err;
  }
  console.log(data);
});
```

fs 모듈을 불러온 뒤 읽을 파일의 경로를 지정한다. **파일 경로는 자바스크립트 파일 기준이 아니라, n ode 명령어를 실행하는 콘솔 기준으로 작동하기 때문에** 주의해야 한다.

위 코드를 실행하면 txt 파일에 있는 텍스트 내용 대신 Buffer라는 것이 출력될 텐데, readFile의 결과물은 버퍼 형식으로 제공되기 때문이다. 따라서 toString()을 이용해 문자열로 변환해야 제대로 사용할 수 있다.

fs 모듈은 기본적으로 콜백 형식이기 때문에 require 뒤에 promises를 붙여 프로미스 형태로 fs 모듈을 사용할 수도 있다.

파일을 쓸 대는 `fs.writeFile(경로, 내용)`형태로 입력하면 파일을 생성할 수 있다.

### 동기 메서드와 비동기 메서드

setTimeout같은 타이머 외에도 노드는 대부분의 메서드를 비동기 방식으로 처리한다. 하지만 몇몇 메서드는 동기 방식으로도 사용할 수 있다.

fs 모듈을 사용하면서, 같은 파일을 readFile 메서드를 이용해 읽어 보면 파일 읽기를 완료하는 순서가 코드의 순서와 일치하지 않는다는 점을 알 수 있다. 이는 비동기 메서드들은 파일 입출력을 요청하고 다음 작업으로 넘어가기 때문이다. 그랬다가 나중에 읽기가 완료되었을 때 백그라운드가 메인 스레드에 완료 사실을 알리고, 메인 스레드가 그 때 등록된 콜백 함수를 실행하기 때문에 코드 실행 시마다 순서가 다른 것이다.

이는 수많은 I/O 요청이 들어와도 메인 스레드는 지속적으로 요청을 받을 수 있으며, I/O 처리는 백그라운드가 하기 때문에 효율적이라는 장점이 있다. 백그라운드에서는 스레드풀을 이용하여 요청 여러 개를 동시에 처리한다.

> 동기와 비동기, 블로킹과 논 블로킹이라는 용어들은 노드에서 자주 등장하는데, 동기와 비동기, 블로킹과 논 블로킹은 서로 다른 의미이다. 동기/비동기는 백그라운드 작업이 완료되는 것을 확인하는지를 나타내며, 블로킹/논 블로킹은 함수가 바로 반환되는지를 나타낸다.

파일 읽기를 순차적으로 처리하고 싶다면 readFile이 대신 readFileSync를 사용하면 된다. 콜백 대신 반환 값을 변수에 직접 대입하는 방식으로 작동하게 되며, 콜백 형태보다 코드를 이해하기 쉽다는 장점이 있다.

하지만 치명적인 단점이 있는데, readFileSync 메서드를 사용하면 이전 작업이 완료된 뒤에 다음 작업을 진행하기 때문에 메인 스레드는 백그라운드 작업이 끝날 때까지 아무 일도 안 하게 된다. 따라서 수많은 요청이 들어올 때 성능에 문제가 생길 수 있으며 비효율적이게 된다. 따라서 일반적으로 노드에서 동기 메서드는 사용하지 않는 경우가 대부분이다.

비동기 메서드를 이용하면서 코드의 실행 순서를 지키고 싶다면, 콜백 내부에 다음 코드를 넣거나 Promise 패턴 혹은 async/await 패턴을 사용하면 된다.

### 버퍼와 스트림

파일을 읽거나 쓰는 방식에는 버퍼를 이용하는 방식과 스트림을 이용하는 방식이 있는데, 파일을 읽을 때 메모리에 파일 크기만큼의 공간을 할당하고 해당 공간에 파일 데이터를 올려둔 것이 버퍼이다.

Buffer 클래스를 이용해 버퍼를 직접 다룰 수 있다.

- from(문자열): 문자열을 버퍼로 바꿀 수 있으며, length 속성은 버퍼의 크기를 바이트 단위로 알린다.
- toString(인코딩): 버퍼를 문자열로 바꾸며, 인수로 인코딩 종류를 입력하면 해당 인코딩으로 변환할 수 있다.
- concat(배열): 배열 안에 든 버퍼들을 하나로 합친다.
- alloc(크기): 빈 버퍼를 생성하며, 바이트 단위의 크기를 입력하면 해당 크기만큼의 버퍼가 생성된다.

버퍼는 편리하지만 문제점이 있는데, 용량이 큰 파일이 있으면 메모리에 해당 용량만큼의 버퍼를 만들어야 한다. 특히나 서버처럼 몇 명이나 이용할지 모르는 환경에서는 메모리 문제가 발생할 수 있다. 또한 모든 내용을 버퍼에 다 쓴 뒤에 다음 동작으로 넘어가기 때문에 비효율적이다. 따라서 이를 작게 나눠 여러 번에 나눠 전송하는 방식이 등장했으며, 이를 편리하게 만든 것이 스트림이다.

파일을 읽는 스트림 메서드로는 createReadStream이 존재하며, `createReadStream(파일 경로, [옵션])`형태로 사용할 수 있다. `readStream.on(이벤트)`를 통해 이벤트 리스너를 붙여 사용하며, 파일을 읽는 도중 오류가 발생하면 error 이벤트, 파일 읽기가 시작되면 data 이벤트, 파일을 다 읽으면 end 이벤트가 발생한다.

파일을 쓰는 스트림 메서드로는 createWriteStream이 존재하며, `createWriteSteam(파일 경로, [옵션])`형태로 사용할 수 있다. 마찬가지로 이벤트 리스너를 붙여 사용할 수 있으며, finish 이벤트로 파일 쓰기가 종료되었을 때 콜백 함수를 호출할 수 있으며, 데이터를 다 썼을 때 end 메서드를 호출하여 finish 이벤트를 발생시킬 수 있다.

createReadStream으로 파일을 읽고 그 스트림을 전달받아 createWriteStream으로 파일을 쓸 수도 있는데, 이렇게 스트림끼리 연결하는 것을 '파이핑'이라고 표현한다. 관(pipe)처럼 데이터가 흐른다는 점에서 유래한 이름이다.

### 기타 메서드들

fs 모듈은 파일 읽기/쓰기 뿐만 아니라 파일을 생성, 삭제할 수 있으며 마찬가지로 폴더 생성, 삭제도 가능하다.

- fs.access(경로, 옵션, 콜백): 폴더나 파일에 접근할 수 있는지를 체크하며, 두 번째 인수로 fs 모듈의 상수를 가져와 특정 권한을 체크할 수도 있다.
- fs.mkdir(경로, 콜백): 폴더를 만드는 메서드로, 이미 폴더가 있다면 오류가 발생한다.
- fs.open(경로, 옵션, 콜백): 파일의 아이디를 가져오는 메서드로, 파일이 없다면 파일을 생성한 뒤 아이디를 가져온다. 가져온 아이디는 fs.read / fs.write에 사용할 수 있으며, 옵션 인수로 어떤 동작을 할 것인지를 설정할 수 있다(w: 쓰기, r: 읽기, a: 기존 파일에 추가).
- fs.rename(기존 경로, 새 경로, 콜백): 파일의 이름을 바꾸는 메서드이다. 기존 경로와 새 경로를 다르게 작성하여 파일을 이동하는 데 사용할 수도 있다.
- fs.readdir(경로, 콜백): 폴더 안의 내용물을 확인할 수 있다. 콜백에 인수로 제공되는 배열 안에 내부 파일과 폴더명이 들어 있다.
- fs.unlink(경로, 콜백): 파일을 지울 수 있다. 파일이 없다면 오류가 발생한다.
- fs.rmdir(경로, 콜백): 폴더를 지울 수 있다. 폴더 안에 파일들이 있다면 오류가 발생한다.
- fs.copyFile(원본 파일, 복사될 파일명): 파이프를 사용하지 않고 파일을 복사할 수 있다.
- fs.watch(파일, 콜백): 파일/폴더의 변경 사항을 감시한다. 내용물을 수정할 때는 change, 파일명을 변경하거나 파일을 삭제한 뒤에는 rename 이벤트가 발생하며, rename 이벤트가 발생하면 더 이상 watch가 수행되지 않는다.
