# 노드 내장 모듈

노드는 웹 브라우저 상에서 실행된다는 제약이 존재하지 않기 때문에, 운영체제 정보 등에도 접근할 수 있다.

노드의 모듈은 노드 버전마다 차이가 존재하며, 따라서 버전과 상관없이 안정적이고 유용한 기능들을 제공하는 모듈 위주로 정리한다.

### os

os 모듈은 운영체제의 정보를 가져올 때 사용되는 모듈이다.

- os.arch(): process.arch와 동일
- os.platform(): process.platform과 동일
- os.type(): 운영체제의 종류
- os.uptime(): 운영체제 부팅 이후 흐른 시간(초 단위)
- os.hostname(): 컴퓨터의 이름
- os.release(): 운영체제 버전
- os.homedir(): 홈 디렉터리 경로
- os.tmpdir(): 임시 파일 저장 경로
- os.cpus(): 컴퓨터의 코어 정보
- os.freemem(): 사용 가능한 메모리
- os.totalmem(): 전체 메모리 용량
- os.cpus().length: CPU 코어 개수
- os.constants: 각종 에러와 신호에 대한 정보를 담고 있음

os 모듈은 컴퓨터 내부 자원에 빈번하게 접근하는 경우에 주로 사용되며, 따라서 일반적인 웹 서비스를 제작할 때는 사용 빈도가 높지 않다.

### path

폴더와 파일의 경로를 쉽게 조작하도록 도와주는 모듈이다. 이 모듈이 가장 자주 사용되는 이유 중 하나는 운영체제별로 경로 구분자가 다르기 때문이다.(\\, /)

- path.sep: 경로 구분자
- path.delimiter: 환경 변수 구분자(윈도우는 세미콜론(;), POSIX(리눅스, 맥 등)은 콜론(:))
- path.dirname(경로): 파일이 위치한 폴더 경로
- path.extname(경로): 파일의 확장자
- path.basename(경로, 확장자): 파일의 이름(확장자 포함)
- path.parse(경로): 파일 경로를 root, dir, base, ext, name으로 분리
- path.format(객체): path.parse()한 객체를 파일 경로로 합침
- path.normalize(경로): 경로 구분자를 여러 번 사용했거나 혼용한 경우 정상적인 경로로 수정
- path.isAbsolute(경로): 해당 경로가 절대경로인지 상대경로인지를 boolean으로 반환
- path.relative(기준경로, 비교경로): 경로를 두 개 넣으면 첫 번째 경로에서 두 번째 경로로 가는 방법을 알려줌
- path.join(경로, ...): 여러 인수를 넣으면 하나의 경로로 합치며, 상대경로인 ..과 .도 알아서 처리
- path.resolve(경로, ...): path.join()과 비슷

> join과 resolve는 비슷하지만 동작 방식이 다른데, /를 만나면 path.resolve는 절대경로로 인식해 앞의 경로를 무시하지만, path.join은 상대경로로 처리한다.
>
> path.join('/a', '/b', 'c'); // /a/b/c
>
> path.resolve('/a', '/b', 'c'); // /b/c

> path 모듈은 주로 윈도우 환경에서 필요한데, 이는 윈도우는 경로 구분자로 \를 사용하기 때문이다. 자바스크립트에서 \는 이스케이프 시퀀스이기 때문에 ..\node같은 경로에서 의도하지 않은 오류가 발생할 수 있으며, 이럴 때는 C:\\\node처럼 사용해야 한다. 그러나 path 모듈은 위와 같은 경우에 발생하는 문제를 알아서 처리한다.

가끔 윈도우에서 POSIX 스타일의 경로를 사용할 때가 있고, 반대로 POSIX에서 윈도우 스타일의 경로를 사용할 떄도 있는데, 이럴 때는 path.posix.join()처럼 사용하고, 반대의 경우는 path.win32.join()처럼 사용하면 된다.

노드는 require.main 파일을 기준으로 상대 경로를 인식하기 때문에, 다른 디렉터리의 파일이 상대 경로를 가지고 있다면 예상과 다르게 동작할 수도 있다. 이 문제도 path 모듈을 통해 해결할 수 있다.

### url

인터넷 주소를 쉽게 조작하도록 도와주는 모듈로, 크게 두 가지 방식이 있는데 노드 버전 7에서 추가된 WHATWG 방식과 예전부터 노드에서 사용하던 방식이 있다.

```
┌────────────────────────────────────────────────────────────────────────────────────────────────┐
│                                              href                                              │
├──────────┬──┬─────────────────────┬────────────────────────┬───────────────────────────┬───────┤
│ protocol │  │        auth         │          host          │           path            │ hash  │
│          │  │                     ├─────────────────┬──────┼──────────┬────────────────┤       │
│          │  │                     │    hostname     │ port │ pathname │     search     │       │
│          │  │                     │                 │      │          ├─┬──────────────┤       │
│          │  │                     │                 │      │          │ │    query     │       │
"  https:   //    user   :   pass   @ sub.example.com : 8080   /p/a/t/h  ?  query=string   #hash "
│          │  │          │          │    hostname     │ port │          │                │       │
│          │  │          │          ├─────────────────┴──────┤          │                │       │
│ protocol │  │ username │ password │          host          │          │                │       │
├──────────┴──┼──────────┴──────────┼────────────────────────┤          │                │       │
│   origin    │                     │         origin         │ pathname │     search     │ hash  │
├─────────────┴─────────────────────┴────────────────────────┴──────────┴────────────────┴───────┤
│                                              href                                              │
└────────────────────────────────────────────────────────────────────────────────────────────────┘
```

url 모듈에는 생성자가 존재하는데, 이 생성자에 주소를 넣어 객체로 만들면 WHATWG 방식으로 정리된 객체가 나오고, url.parse(주소) 형태로 사용하면 기존 노드 방식에 맞춰 주소가 분해된다.

WHATWG와 노드 방식은 취향에 따라 선택하면 되지만, host 부분이 없이 pathname 부분만 오는 주소인 경우에는 WHATWG 방식이 처리할 수 없다. 따라서 그런 경우에는 노드 방식을 사용해야만 한다.

WHATWG 방식은 search 부분을 searchParams라는 특수한 객체로 반환하기 때문에 유용하다. searchParams 객체 안에는 search 부분을 조작하는 다양한 메서드를 지원한다.

- getAll(키): 키에 해당하는 모든 값들을 가져온다.
- get(키): 키에 해당하는 첫 번째 값만 가져온다.
- has(키): 해당 키가 있는지 없는지를 검사한다.
- keys(): searchParams의 모든 키를 iterator(반복기) 객체로 가져온다.
- values(): searchParams의 모든 값을 iterator(반복기) 객체로 가져온다.
- append(키, 값): 해당 키를 추가한다. 같은 키의 값이 있다면 유지하고 하나를 더 추가한다.
- set(키, 값): append와 비슷하지만, 같은 키의 값들을 모두 지우고 새로 추가한다.
- delete(키): 해당 키를 제거한다.
- toString(): 조작한 searchParams 객체를 다시 문자열로 만든다.

query 등의 문자열보다 searchParams가 유용한 이유는 query의 경우 querystring 모듈을 한 번 더 사용해야 하기 때문이다.

### querystring

WHATWG 방식의 url 대신 기존 노드의 url을 사용할 때, search 부분을 사용하기 쉽게 객체로 만드는 모듈이다.

- parse(쿼리): url의 query 부분을 자바스크립트 객체로 분해한다.
- stringify(객체): 분해된 query 객체를 문자열로 다시 조립한다.

### crypto

다양한 방식의 암호화를 도와주는 모듈로, 실제 서비스에도 적용할 수 있어 유용한 모듈이다.

#### 단방향 암호화

단방향 암호화란 복호화할 수 없는 암호화 방식을 뜻하며, 따라서 단방향 암호화를 한 번 하면 원ㄹ ㅐ문자열로 되돌릴 수 없다. 복호화하는 것이 불가능하기 때문에 암호화라고 표현하는 대신 해시 함수라고 표현하기도 한다.

복호화할 수 없는 암호화가 왜 필요한지 의문이 들 수도 있는데, 사실 고객의 비밀번호는 복호화할 필요가 없다. 고객의 비밀번호를 단방향 암호화하여 데이터베이스에 저장한 뒤, 로그인할 때마다 입력받을 비밀번호를 똑같은 방식으로 암호화하여 암호화된 결과를 비교하면 되기 때문이다.

노드에서 해시 함수는 다음과 같이 사용할 수 있다.

```javascript
const crypto = require("crypto");

crypto.createHash("알고리즘").update("문자열").digest("인코딩");
```

- createHash(알고리즘): 사용할 해시 알고리즘을 입력하며, **md5**, **sha1**, **sha256**, **sha512**등을 사용할 수 있지만, md5와 sha1은 이미 취약점이 발견되었기 때문에 사용하지 않는 것이 권장된다. sha2에 속하는 sha256과 sha512는 알고리즘의 기본 원리가 sha1과 비슷하기 때문에 안전하다고 장담할 수는 없지만, sha256 기준으로 경우의 수가 2^256개나 되기 때문에 현재로썬 안전하다고 판단할 수 있는 상태이다.
- update(문자열): 해시 함수를 이용해 변환할 문자열을 입혁한다.
- digest(인코딩): 인코딩할 알고리즘을 넣으며, 주로 base64나 hex를 사용한다. 일반적으로는 base64가 길이가 가장 짧아 애용되는 편이다.

현재 취약하다고 알려진 해시 알고리즘을 사용하다 보면 서로 다른 문자열을 입력했는데 출력되는 해시 값이 같은 경우가 있다. 이를 **해시 충돌**이라고 표현하며, 이는 비밀번호 등의 무결성을 검증하는 해시에서는 큰 보안 위협이기 때문에 해시를 해킹한다는 것은 이러한 충돌을 찾아내는 것이 목적이며, 해시 충돌이 한 번이라도 발생한 해시 함수는 더 이상 사용되지 않는 것이 일반적이다.
