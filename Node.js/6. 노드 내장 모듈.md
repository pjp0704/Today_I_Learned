# 노드 내장 모듈

노드는 웹 브라우저 상에서 실행된다는 제약이 존재하지 않기 때문에, 운영체제 정보 등에도 접근할 수 있다.

노드의 모듈은 노드 버전마다 차이가 존재하며, 따라서 버전과 상관없이 안정적이고 유용한 기능들을 제공하는 모듈 위주로 정리한다.

### os

os 모듈은 운영체제의 정보를 가져올 때 사용되는 모듈이다.

- os.arch(): process.arch와 동일
- os.platform(): process.platform과 동일
- os.type(): 운영체제의 종류
- os.uptime(): 운영체제 부팅 이후 흐른 시간(초 단위)
- os.hostname(): 컴퓨터의 이름
- os.release(): 운영체제 버전
- os.homedir(): 홈 디렉터리 경로
- os.tmpdir(): 임시 파일 저장 경로
- os.cpus(): 컴퓨터의 코어 정보
- os.freemem(): 사용 가능한 메모리
- os.totalmem(): 전체 메모리 용량
- os.cpus().length: CPU 코어 개수
- os.constants: 각종 에러와 신호에 대한 정보를 담고 있음

os 모듈은 컴퓨터 내부 자원에 빈번하게 접근하는 경우에 주로 사용되며, 따라서 일반적인 웹 서비스를 제작할 때는 사용 빈도가 높지 않다.

### path

폴더와 파일의 경로를 쉽게 조작하도록 도와주는 모듈이다. 이 모듈이 가장 자주 사용되는 이유 중 하나는 운영체제별로 경로 구분자가 다르기 때문이다.(\\, /)

- path.sep: 경로 구분자
- path.delimiter: 환경 변수 구분자(윈도우는 세미콜론(;), POSIX(리눅스, 맥 등)은 콜론(:))
- path.dirname(경로): 파일이 위치한 폴더 경로
- path.extname(경로): 파일의 확장자
- path.basename(경로, 확장자): 파일의 이름(확장자 포함)
- path.parse(경로): 파일 경로를 root, dir, base, ext, name으로 분리
- path.format(객체): path.parse()한 객체를 파일 경로로 합침
- path.normalize(경로): 경로 구분자를 여러 번 사용했거나 혼용한 경우 정상적인 경로로 수정
- path.isAbsolute(경로): 해당 경로가 절대경로인지 상대경로인지를 boolean으로 반환
- path.relative(기준경로, 비교경로): 경로를 두 개 넣으면 첫 번째 경로에서 두 번째 경로로 가는 방법을 알려줌
- path.join(경로, ...): 여러 인수를 넣으면 하나의 경로로 합치며, 상대경로인 ..과 .도 알아서 처리
- path.resolve(경로, ...): path.join()과 비슷

> join과 resolve는 비슷하지만 동작 방식이 다른데, /를 만나면 path.resolve는 절대경로로 인식해 앞의 경로를 무시하지만, path.join은 상대경로로 처리한다.
>
> path.join('/a', '/b', 'c'); // /a/b/c
>
> path.resolve('/a', '/b', 'c'); // /b/c

> path 모듈은 주로 윈도우 환경에서 필요한데, 이는 윈도우는 경로 구분자로 \를 사용하기 때문이다. 자바스크립트에서 \는 이스케이프 시퀀스이기 때문에 ..\node같은 경로에서 의도하지 않은 오류가 발생할 수 있으며, 이럴 때는 C:\\\node처럼 사용해야 한다. 그러나 path 모듈은 위와 같은 경우에 발생하는 문제를 알아서 처리한다.

가끔 윈도우에서 POSIX 스타일의 경로를 사용할 때가 있고, 반대로 POSIX에서 윈도우 스타일의 경로를 사용할 떄도 있는데, 이럴 때는 path.posix.join()처럼 사용하고, 반대의 경우는 path.win32.join()처럼 사용하면 된다.

노드는 require.main 파일을 기준으로 상대 경로를 인식하기 때문에, 다른 디렉터리의 파일이 상대 경로를 가지고 있다면 예상과 다르게 동작할 수도 있다. 이 문제도 path 모듈을 통해 해결할 수 있다.

### url

인터넷 주소를 쉽게 조작하도록 도와주는 모듈로, 크게 두 가지 방식이 있는데 노드 버전 7에서 추가된 WHATWG 방식과 예전부터 노드에서 사용하던 방식이 있다.

```
┌────────────────────────────────────────────────────────────────────────────────────────────────┐
│                                              href                                              │
├──────────┬──┬─────────────────────┬────────────────────────┬───────────────────────────┬───────┤
│ protocol │  │        auth         │          host          │           path            │ hash  │
│          │  │                     ├─────────────────┬──────┼──────────┬────────────────┤       │
│          │  │                     │    hostname     │ port │ pathname │     search     │       │
│          │  │                     │                 │      │          ├─┬──────────────┤       │
│          │  │                     │                 │      │          │ │    query     │       │
"  https:   //    user   :   pass   @ sub.example.com : 8080   /p/a/t/h  ?  query=string   #hash "
│          │  │          │          │    hostname     │ port │          │                │       │
│          │  │          │          ├─────────────────┴──────┤          │                │       │
│ protocol │  │ username │ password │          host          │          │                │       │
├──────────┴──┼──────────┴──────────┼────────────────────────┤          │                │       │
│   origin    │                     │         origin         │ pathname │     search     │ hash  │
├─────────────┴─────────────────────┴────────────────────────┴──────────┴────────────────┴───────┤
│                                              href                                              │
└────────────────────────────────────────────────────────────────────────────────────────────────┘
```

url 모듈에는 생성자가 존재하는데, 이 생성자에 주소를 넣어 객체로 만들면 WHATWG 방식으로 정리된 객체가 나오고, url.parse(주소) 형태로 사용하면 기존 노드 방식에 맞춰 주소가 분해된다.

WHATWG와 노드 방식은 취향에 따라 선택하면 되지만, host 부분이 없이 pathname 부분만 오는 주소인 경우에는 WHATWG 방식이 처리할 수 없다. 따라서 그런 경우에는 노드 방식을 사용해야만 한다.

WHATWG 방식은 search 부분을 searchParams라는 특수한 객체로 반환하기 때문에 유용하다. searchParams 객체 안에는 search 부분을 조작하는 다양한 메서드를 지원한다.

- getAll(키): 키에 해당하는 모든 값들을 가져온다.
- get(키): 키에 해당하는 첫 번째 값만 가져온다.
- has(키): 해당 키가 있는지 없는지를 검사한다.
- keys(): searchParams의 모든 키를 iterator(반복기) 객체로 가져온다.
- values(): searchParams의 모든 값을 iterator(반복기) 객체로 가져온다.
- append(키, 값): 해당 키를 추가한다. 같은 키의 값이 있다면 유지하고 하나를 더 추가한다.
- set(키, 값): append와 비슷하지만, 같은 키의 값들을 모두 지우고 새로 추가한다.
- delete(키): 해당 키를 제거한다.
- toString(): 조작한 searchParams 객체를 다시 문자열로 만든다.

query 등의 문자열보다 searchParams가 유용한 이유는 query의 경우 querystring 모듈을 한 번 더 사용해야 하기 때문이다.
