# const와 let

**const**와 **let**은 변수를 선언할 때, 기존의 **var**를 대체하기 위해 만들어졌다.

### var의 문제점

기존에 사용되던 var의 문제점은 **함수 스코프**를 따른다는 것이다. 이는 var를 처음 접하는 사람들이 코드를 짤 때 var로 선언한 변수를 예상보다 더 넓은 범위에서 접근이 가능한 문제가 발생하였고, 호이스팅 때문에 함수 선언과 변수 선언의 위치가 달라져 코드의 실행 순서가 꼬이는 상황도 발생할 수 있다.

> 호이스팅이 뭔데요?
>
> 호이스팅이란 자바스크립트에서 함수와 변수 선언문이 해당 스코프 내의 최상단으로 끌어 올려지는 현상을 말한다. 예시로 아래의 코드를 들 수 있다.
>
> ```javascript
> func();
> function func() {
>   console.log("test");
> }
> ```
>
> 저렇게 생긴 코드는 얼핏 보면 함수가 선언되기 전에 사용되었기 때문에 잘못된 코드로 보일 수 있지만, 자바스크립트에서는 함수를 선언하는 부분이 위로 끌어올려진 뒤에 함수를 호출한 것이 되기 때문에 정상적으로 test라는 문구가 출력된다.

> 사실 호이스팅은 **자바스크립트에서 공식적으로 정의된 용어나 스펙이 아니다.** 그저 위에 설명된 동작을 설명하기 위해 만들어진 용어이다.

### const, let이 가지는 var와의 차이점

우선 가장 큰 차이는 **함수 단위 스코프**로 동작하던 기존 var와는 다르게 **블록 단위 스코프**로 동작한다는 점이다.

2. 호이스팅과 TDZ(Temporary Dead Zone)

우리가 원래 쓰던 var는,

```javascript
(function () {
  console.log(x); // undefined
  var x = 10;
})();
```

라는 결과를 출력하였다.

> 위 코드는 함수를 선언한 즉시 실행하는 코드이다. 이해가 되지 않는다면 자바스크립트의 IIFE에 관한 설명을 찾아보고 이해해야 한다.

그러나 let/const는 지금까지의 var와는 다르게,

```javascript
(() => {
  console.log(z); // Uncaught ReferenceError: z is not defined
  const z = 10;
})();
```

위와 같이 ReferenceError가 발생하게 된다.

그렇다면 const와 let은 호이스팅이 일어나지 않는 것인가? 답은 **아니다.**
우선 const와 let의 동작을 이해하기 위해서는 TDZ(Temporary Dead Zone)에 대한 이해가 필요하다.

> TDZ도 정확히는 호이스팅과 같이 **공식 용어나 스펙은 아니다.** 단지 var와의 차이점을 알기 쉽게 정의하기 위해 사용된 언어라고 보는 것이 좋다.

#### TDZ?

이 코드를 한 번 살펴보자.

```javascript
x = 10; // ReferenceError: Cannot access 'x' before initialization
let x = 20;
```

분명 호이스팅이 되지 않았다면, 저 구문은 ReferenceError가 아니라,

> SyntaxError: Identifier 'x' has already been declared

이런 에러를 뱉었어야 했다. 왜냐하면 이미 사용 중인 x에 새로운 let 변수를 할당하는 코드가 되어버리기 때문이다.

그러나 저 코드는 **ReferenceError: Cannot access 'x' before initialization**이라는 오류를 발생시켰다.
